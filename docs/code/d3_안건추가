import re
import pandas as pd
from pathlib import Path
from typing import Optional, List, Dict, Set, Tuple
from rdflib import Graph, Literal, URIRef, Namespace
from rdflib.namespace import RDF, RDFS, SKOS, DCTERMS, FOAF, XSD

# ========================= CONFIG =========================
CSV_PATH         = r"D:/연구/국회회의록/21대_상임위_최종병합.csv"
CSV_ENCODING     = "utf-8-sig"

OUT_TTL_D3       = r"D:/연구/국회회의록/d3_content_add_AB_SC.txt"          # AgendaItem & Bill
OUT_TTL_SUBJECT  = r"D:/연구/국회회의록/d1_record_add_subject_SC.txt"      # hasOrHadSubject 전용
OUT_TMP_PEOPLE   = r"D:/연구/국회회의록/d2_person_tmp_add_4.txt"

PEOPLE_TTL       = r"https://lseun135.github.io/NAontology_study/resource/d2-person.ttl"

# (선택) 과거 d3 파일/URL을 넣으면 그 안의 Bill creator만 보강 시 참조
PRELOAD_D3_TTLS: List[str] = [
    # 예: r"https://lseun135.github.io/NAontology_study/resource/d3-content.ttl",
]

# ========================= NAMESPACES =========================
NAM1   = Namespace("https://lseun135.github.io/NAontology_study/m1-record#")
NAM2   = Namespace("https://lseun135.github.io/NAontology_study/m2-person#")
NAM3   = Namespace("https://lseun135.github.io/NAontology_study/m3-content#")

NADAT1 = Namespace("https://lseun135.github.io/NAontology_study/resource/d1-record#")
NADAT2 = Namespace("https://lseun135.github.io/NAontology_study/resource/d2-person#")
NADAT3 = Namespace("https://lseun135.github.io/NAontology_study/resource/d3-content#")

RICO   = Namespace("https://www.ica.org/standards/RiC/ontology#")
SCHEMA = Namespace("https://schema.org/")

# ========================= 유틸 =========================
def digits_only(s) -> Optional[int]:
    if s is None or (isinstance(s, float) and pd.isna(s)): return None
    m = re.findall(r"\d+", str(s))
    return int("".join(m)) if m else None

def pad(n: Optional[int], width: int) -> Optional[str]:
    return f"{n:0{width}d}" if n is not None else None

def to_r_id(gen: int, session4: str, round3: str, meeting_no: int) -> str:
    return f"R1000{gen}{session4}{round3}{meeting_no}"

def to_agenda_base(gen: int, session4: str, round3: str, meeting_no: int) -> str:
    return f"AGD-R1000{gen}{session4}{round3}{meeting_no}"

# ---------- 안건 분리 ----------
# 상위안건: 1. 2. 3. ...
_TOP_NUM_RE   = r'(?<!\d)(\d+)\.\s*'
# 하위안건: 가. 나. 다. 라. 마. 바. 사. 아. 자. 차. 카. 타. 파. 하.
_KR_SUB_LIST  = ['가','나','다','라','마','바','사','아','자','차','카','타','파','하']
_SUB_KR_RE    = r'(?:' + '|'.join(_KR_SUB_LIST) + r')\.\s*'
# 기호안건: o 또는 ○
_O_BULLET_RE  = r'[o○]\s+'

# 통합 마커(상위/하위/기호) 감지
# - 그룹명: num(숫자), sub(가/나/..), o(기호)
_BULLET_OR_O_RE = re.compile(
    rf'(?P<num>{_TOP_NUM_RE})|(?P<sub>{_SUB_KR_RE})|(?P<o>{_O_BULLET_RE})',
    re.MULTILINE
)

def _segment_with_markers(text: str):
    """텍스트 내 마커들의 (start, end, kind, match_text) 리스트"""
    segs = []
    for m in _BULLET_OR_O_RE.finditer(text):
        kind = 'num' if m.group('num') else ('sub' if m.group('sub') else 'o')
        segs.append((m.start(), m.end(), kind, m.group(0)))
    return segs

def split_agenda_cell(cell: str) -> List[str]:
    """
    기존 호출부와의 역호환용:
    - 상위안건(1.), 하위안건(가.), 기호(o/○) 기준으로 '평평한' 문자열 리스트를 반환
    - 계층정보는 포함하지 않음 (필요시 아래 split_agenda_cell_with_hierarchy 사용)
    """
    if cell is None or (isinstance(cell, float) and pd.isna(cell)):
        return []
    text = str(cell).strip()
    if not text:
        return []
    segs = _segment_with_markers(text)
    if not segs:
        return [text]
    # 맨 앞에 마커가 없으면 0부터 시작해서 첫 마커 전 구간도 포함
    starts = [s for (s, _, _, _) in segs]
    if starts[0] != 0:
        segs = [(0, 0, 'txt', '')] + segs  # dummy head
    parts = []
    # 각 마커의 시작~다음 마커 시작 전까지를 한 항목으로
    boundaries = [s for (s, _, _, _) in segs]
    boundaries.append(len(text))
    for i in range(len(segs)):
        s = boundaries[i]
        e = boundaries[i+1]
        seg = text[s:e].strip()
        if seg:
            parts.append(seg)
    return parts

def split_agenda_cell_with_hierarchy(cell: str):
    """
    계층정보 포함 버전:
    반환: List[Dict]  —  {'text': ..., 'level': 0|1, 'marker': '1.'|'가.'|'o', 'kind': 'num'|'sub'|'o'}
    - level=0: 상위안건(숫자) 또는 기호(o/○)
    - level=1: 하위안건(가/나/…)
    """
    if cell is None or (isinstance(cell, float) and pd.isna(cell)):
        return []
    text = str(cell).strip()
    if not text:
        return []
    segs = _segment_with_markers(text)
    if not segs:
        # 마커가 없으면 level=0 단일 항목으로 본다
        return [{'text': text, 'level': 0, 'marker': None, 'kind': 'txt'}]
    # 경계 산출
    boundaries = [s for (s, _, _, _) in segs]
    if boundaries[0] != 0:
        segs = [(0, 0, 'txt', '')] + segs
        boundaries = [0] + boundaries
    boundaries.append(len(text))
    items = []
    for i, (s, _, kind, marker_txt) in enumerate(segs):
        seg = text[boundaries[i]:boundaries[i+1]].strip()
        if not seg:
            continue
        # 레벨 판정
        if kind == 'sub':
            level = 1
            marker_norm = marker_txt.strip()
        elif kind in ('num', 'o'):
            level = 0
            marker_norm = marker_txt.strip()
        else:
            # dummy head 또는 일반 텍스트가 맨 앞에 있을 때: 상위로 처리
            level = 0
            marker_norm = None
        items.append({
            'text': seg,
            'level': level,
            'marker': marker_norm,
            'kind': kind
        })
    return items

# ---------- 괄호/의안번호 ----------
_PAREN_RE = re.compile(r"\((.*?)\)")
_BILL_NO_RE = re.compile(r"의안번호\s*([0-9]{3,})")  # "의안번호 ####"만

def parse_paren_chunks(s: str) -> List[str]:
    """본문 전체의 괄호 내용(모든 위치)을 순서대로 추출"""
    return [m.strip() for m in _PAREN_RE.findall(s or "")]

def trailing_paren_chunks(s: str) -> List[str]:
    """
    문자열 '끝부분'에 연속으로 오는 괄호열만 추출.
    예) '... 안건명(제출자)(의안번호 1234)' -> ['제출자', '의안번호 1234']
        '... 대법관(신숙희) 임명동의안(의안번호 2126515)' -> ['의안번호 2126515']
    """
    if not s: return []
    m = re.search(r'((?:\s*\([^)]*\))+)\s*$', str(s))
    if not m: return []
    suffix = m.group(1)
    return [t.strip() for t in re.findall(r'\(([^)]*)\)', suffix)]

def extract_bill_no(parens: List[str]) -> Optional[str]:
    for p in parens:
        if not p: continue
        m = _BILL_NO_RE.search(str(p))
        if m: return m.group(1)
    return None

def is_alt_by_parens(parens: List[str]) -> bool:
    # (본문 어디든) "대안"이 보이면 ALT
    return any("대안" in (p or "").strip() for p in parens)

def starts_with_digit(text: str) -> bool:
    return bool(re.match(r"^\s*\d+", text or ""))

def normalize_label_for_dedup(text: str) -> str:
    return re.sub(r"\s+", " ", str(text or "")).strip()

# ---------- 순수 안건명(title) 추출 ----------
def extract_pure_agenda_title(item_text: str) -> str:
    """
    [예] '1. 대법관(신숙희) 임명동의안(의안번호 2126515)' -> '1. 대법관(신숙희) 임명동의안(의안번호 2126515)'
         'o 비교섭단체(녹색정의당) 대표발언'              -> 'o 비교섭단체(녹색정의당) 대표발언'
    즉, 번호/기호(o, ○)는 그대로 보존하고, 공백만 정규화.
    """
    t = str(item_text or "")
    return re.sub(r"\s+", " ", t).strip()

# ---------- 제출자 선택 & 이름 추출 ----------
ROLE_STOPWORDS = {
    # 직함/기관/비인명/절차/위원회명 키워드(필요시 확장)
    "대안","대통령","국무총리","총리","부총리","장관","차관","청장","총장","국장","과장","실장","소장","원장","처장",
    "의장","부의장","위원","위원장","간사","대변인","직무대리","직무대행","위원회","제출","제의",
    "환경노동","정무","법제사법","행정안전","교육","외교","국방","기재","농해수","산자중기","보건복지","문체","국토",
    "정부","국회","정부위원","의사일정","본회의","대표발의","발의","서면동의","동의","추천","제청","제출자", "의안번호", "대표"
}
NAME_TOKEN_RE = re.compile(r"(?<![가-힣])([가-힣]{2,4})(?![가-힣])")

def select_submitter_paren_from_trailing(raw_text: str) -> Optional[str]:
    """
    맨 끝 괄호열만 대상으로, 괄호가 2개면 첫번째, 3개면 두번째를 제출자 후보로 선택.
    그 외(1개, 4개 이상)는 제출자 없음 처리.
    """
    if not raw_text or not str(raw_text).strip().endswith(")"):
        return None
    tps = trailing_paren_chunks(raw_text)
    n = len(tps)
    if n == 2:
        return tps[0]
    if n == 3:
        return tps[1]
    return None

def extract_person_name_only(text: Optional[str]) -> Optional[str]:
    """괄호 텍스트에서 '이름'만 반환. 기관/직함/대안 등은 제외."""
    if not text:
        return None
    s = str(text).strip()
    if not s:
        return None
    # ALT 표시는 제출자 아님
    if "대안" in s:
        return None
    # 기관/직책 키워드가 있으면 '○○ 의원' 명시형만 통과, 아니면 None
    if any(k in s for k in ["정부", "국회", "의장", "위원장", "장관", "차관", "위원회"]):
        m = re.search(r"([가-힣]{2,4})\s*의원\b", s)
        if m and m.group(1) not in ROLE_STOPWORDS:
            return m.group(1)
        return None
    # 명시형 패턴
    m = re.search(r"([가-힣]{2,4})\s*의원\b", s)
    if m and m.group(1) not in ROLE_STOPWORDS:
        return m.group(1)
    m = re.search(r"([가-힣]{2,4})\s*(대표발의|발의|서면동의|동의|서명)\b", s)
    if m and m.group(1) not in ROLE_STOPWORDS:
        return m.group(1)
    # fallback: 일반 토큰 스캔(더 엄격)
    for m in NAME_TOKEN_RE.finditer(s):
        cand = m.group(1)
        if cand in ROLE_STOPWORDS:
            continue
        right = s[m.end(1):]
        if re.match(r"^(위원장|장관|차관|의장|위원회|정부|국회)", right):
            continue
        return cand
    return None

# ================= nadat2 인물 인덱스 & PER-TMP 시작값 =================
def build_person_index_by_rdfs_label(people_ttl: Optional[str]) -> Dict[str, str]:
    if not people_ttl: return {}
    g = Graph()
    try: g.parse(people_ttl, format="turtle")
    except Exception: return {}
    idx = {}
    for s in set(g.subjects(RDF.type, FOAF.Person)):
        for o in g.objects(s, RDFS.label):
            if isinstance(o, Literal) and str(o).strip():
                idx[str(o).strip()] = str(s)
    return idx

def get_existing_prov_start(people_ttl: Optional[str]) -> int:
    if not people_ttl: return 0
    try:
        g = Graph(); g.parse(people_ttl, format="turtle")
        pat = re.compile(r"(?:/|#)PER\-TMP\-(\d{5})$")
        mx = 0
        for s in g.subjects():
            if isinstance(s, URIRef):
                m = pat.search(str(s))
                if m:
                    n = int(m.group(1)); mx = max(mx, n)
        return mx
    except Exception:
        return 0

class ProvisionalPeople:
    """라벨 기준 재사용(중복 방지) + 기존 최대 번호 이어붙임"""
    def __init__(self, start_from: int = 0):
        self.counter = start_from
        self.created: List[Tuple[str,str]] = []     # (local_id, label)
        self._label2iri: Dict[str, str] = {}        # label -> IRI (중복 방지)

    def mint(self, label_ko: str) -> str:
        key = (label_ko or "").strip()
        if not key:
            raise ValueError("empty label for provisional person")
        if key in self._label2iri:
            return self._label2iri[key]
        self.counter += 1
        local = f"PER-TMP-{self.counter:05d}"
        iri = str(NADAT2[local])
        self.created.append((local, key))
        self._label2iri[key] = iri
        return iri

    def write_ttl(self, path: str):
        out = Path(path); out.parent.mkdir(parents=True, exist_ok=True)
        lines = []
        lines.append('@prefix foaf:  <http://xmlns.com/foaf/0.1/> .')
        lines.append('@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .')
        lines.append('@prefix nam2:  <https://lseun135.github.io/NAontology_study/m2-person#> .')
        lines.append('@prefix nadat2: <https://lseun135.github.io/NAontology_study/resource/d2-person#> .')
        lines.append('')
        lines.append('## 임시 개체 (이름이 확인된 경우에만 생성)')
        lines.append('')
        for local, label in self.created:
            lines.append(f"nadat2:{local} a foaf:Person ;")
            lines.append(f'\trdfs:label "{label}"@ko ;')
            lines.append(f'\tfoaf:name "{label}"@ko ;')
            lines.append(f"\tnam2:isInAStateOf nam2:Provisional .")
            lines.append('')
        out.write_text("\n".join(lines), encoding="utf-8")

# ========= 기존 d3의 creator만 참고 =========
def _safe_parse_into(graph: Graph, source: str):
    try:
        graph.parse(source, format="turtle")
    except Exception:
        pass

def preload_existing_creators(sources: List[str]) -> Dict[str, Set[str]]:
    creators: Dict[str, Set[str]] = {}
    g = Graph()
    for src in sources or []: _safe_parse_into(g, src)
    for s in set(g.subjects(RDF.type, NAM3.Bill)):
        sid = None
        for o in g.objects(s, SCHEMA.identifier):
            if isinstance(o, Literal):
                sid = str(o); break
        if not sid and isinstance(s, URIRef):
            sid = str(s).rsplit("#", 1)[-1]
        if not sid: continue
        for o in g.objects(s, SCHEMA.creator):
            creators.setdefault(sid, set()).add(str(o))
    return creators

# ========= 그래프 내 존재 확인(이 실행에서만) =========
def graph_has_bill(g: Graph, bill_iri: URIRef) -> bool:
    return (bill_iri, RDF.type, NAM3.Bill) in g

def ensure_bill_defined(g: Graph, bill_no: str) -> URIRef:
    bill_id  = f"BILL-{bill_no}"
    bill_iri = URIRef(NADAT3[bill_id])
    if not graph_has_bill(g, bill_iri):
        g.add((bill_iri, RDF.type, NAM3.Bill))
        g.add((bill_iri, SCHEMA.identifier, Literal(bill_id)))
        g.add((bill_iri, DCTERMS.identifier, Literal(bill_no)))
    return bill_iri

def ensure_alt_bill_defined(g: Graph, bill_no: str) -> URIRef:
    alt_bill_id  = f"BILL-ALT-{bill_no}"
    alt_bill_iri = URIRef(NADAT3[alt_bill_id])
    if not graph_has_bill(g, alt_bill_iri):
        g.add((alt_bill_iri, RDF.type, NAM3.Bill))
        g.add((alt_bill_iri, SCHEMA.identifier, Literal(alt_bill_id)))
        g.add((alt_bill_iri, RDFS.comment, Literal("대안", lang="ko")))
    return alt_bill_iri

# ================= 메인 변환 =================
def convert(csv_path: str,
            out_ttl_d3: str,
            out_ttl_subject: str,
            out_tmp_people: str,
            encoding: str = "utf-8-sig",
            people_ttl: Optional[str] = None):
    df = pd.read_csv(csv_path, encoding=encoding)

    # 본문 그래프 (AgendaItem & Bill 등)
    g_main = Graph()
    for pfx, ns in [("rdf", RDF), ("rdfs", RDFS), ("skos", SKOS), ("dcterms", DCTERMS),
                    ("foaf", FOAF), ("xsd", XSD), ("rico", RICO), ("schema", SCHEMA),
                    ("nam1", NAM1), ("nam2", NAM2), ("nam3", NAM3),
                    ("nadat1", NADAT1), ("nadat2", NADAT2), ("nadat3", NADAT3)]:
        g_main.bind(pfx, ns)

    # subject 전용 그래프
    g_subj = Graph()
    for pfx, ns in [("rdf", RDF), ("rdfs", RDFS), ("rico", RICO),
                    ("nadat1", NADAT1), ("nadat3", NADAT3)]:
        g_subj.bind(pfx, ns)

    person_idx = build_person_index_by_rdfs_label(people_ttl)
    prov_start = get_existing_prov_start(people_ttl)
    prov = ProvisionalPeople(start_from=prov_start)

    # 과거 파일의 Bill.creator만 참고
    pre_creators = preload_existing_creators(PRELOAD_D3_TTLS)

    # R별 시퀀스 & 중복 안건(라벨 기반)
    seq_map: Dict[str, int] = {}
    seen_labels_per_r: Dict[str, Set[str]] = {}

    for _, row in df.iterrows():
        try:
            gen = int(row["대수"]) if not pd.isna(row["대수"]) else None
            session_raw = row.get("회수")
            round_raw   = row.get("차수")
            meeting_no  = int(row["회의번호"]) if not pd.isna(row["회의번호"]) else None
            if gen is None or session_raw is None or round_raw is None or meeting_no is None:
                continue

            session4 = pad(digits_only(session_raw), 4)
            round3   = pad(digits_only(round_raw), 3)
            if session4 is None or round3 is None:
                continue

            r_local = to_r_id(gen, session4, round3, meeting_no)
            r_iri   = str(NADAT1[r_local])
            act_iri = str(NADAT1[f"ACT-M-{meeting_no}"])

            # --- 계층형 안건 분리로 교체 ---
            hitems = split_agenda_cell_with_hierarchy(row.get("안건"))
            if not hitems:
                continue

            if r_local not in seq_map:            seq_map[r_local] = 0
            if r_local not in seen_labels_per_r:  seen_labels_per_r[r_local] = set()

            current_parent_local: Optional[str] = None
            current_parent_iri: Optional[URIRef] = None
            sub_seq_map: Dict[str, int] = {}  # 부모별 하위안건 등록순

            for h in hitems:
                raw_item = h.get('text') or ''
                level    = h.get('level', 0)

                if not raw_item.strip():
                    continue

                main_label = normalize_label_for_dedup(raw_item)
                if main_label in seen_labels_per_r[r_local]:
                    continue
                seen_labels_per_r[r_local].add(main_label)

                # ALT/의안번호: 본문 전체 괄호 기준
                all_parens = parse_paren_chunks(raw_item)
                is_alt     = is_alt_by_parens(all_parens)
                bill_no    = extract_bill_no(all_parens)

                # 제출자: 맨 끝 괄호열만
                chosen_paren   = select_submitter_paren_from_trailing(raw_item)
                submitter_name = extract_person_name_only(chosen_paren) if chosen_paren else None
                submitter_iri: Optional[str] = None
                if submitter_name and submitter_name not in ROLE_STOPWORDS:
                    submitter_iri = person_idx.get(submitter_name) or prov.mint(submitter_name)

                if level == 0:
                    # ===== 상위안건 생성 =====
                    seq_map[r_local] += 1
                    agd_local = f"{to_agenda_base(gen, session4, round3, meeting_no)}-{seq_map[r_local]:03d}"
                    agd_iri   = URIRef(NADAT3[agd_local])

                    g_main.add((agd_iri, RDF.type, NAM3.AgendaItem))
                    g_main.add((agd_iri, SKOS.prefLabel, Literal(f"[{agd_local}] {main_label}", lang="ko")))
                    pure_title = extract_pure_agenda_title(raw_item)
                    g_main.add((agd_iri, DCTERMS.title, Literal(pure_title, lang="ko")))
                    g_main.add((agd_iri, DCTERMS.source, URIRef(r_iri)))
                    g_main.add((agd_iri, DCTERMS.isPartOf, URIRef(act_iri)))  # 회의(Activity) 포함
                    if is_alt:
                        g_main.add((agd_iri, RDFS.comment, Literal("대안", lang="ko")))

                    # 숫자로 시작하는 상위안건만 Record → hasOrHadSubject
                    if starts_with_digit(raw_item):
                        g_subj.add((URIRef(r_iri), RICO.hasOrHadSubject, agd_iri))

                    # Bill 연결(+ creator)
                    if bill_no:
                        if is_alt:
                            alt_bill_iri = ensure_alt_bill_defined(g_main, bill_no)
                            g_main.add((agd_iri, DCTERMS.subject, alt_bill_iri))
                            if submitter_iri:
                                sid = f"BILL-ALT-{bill_no}"
                                if str(URIRef(submitter_iri)) not in pre_creators.get(sid, set()) and \
                                   (alt_bill_iri, SCHEMA.creator, URIRef(submitter_iri)) not in g_main:
                                    g_main.add((alt_bill_iri, SCHEMA.creator, URIRef(submitter_iri)))
                        else:
                            bill_iri = ensure_bill_defined(g_main, bill_no)
                            g_main.add((agd_iri, DCTERMS.subject, bill_iri))
                            if submitter_iri:
                                sid = f"BILL-{bill_no}"
                                if str(URIRef(submitter_iri)) not in pre_creators.get(sid, set()) and \
                                   (bill_iri, SCHEMA.creator, URIRef(submitter_iri)) not in g_main:
                                    g_main.add((bill_iri, SCHEMA.creator, URIRef(submitter_iri)))

                    # 부모 컨텍스트 갱신
                    current_parent_local = agd_local
                    current_parent_iri   = agd_iri
                    sub_seq_map.setdefault(current_parent_local, 0)

                else:
                    # ===== 하위안건 생성 =====
                    # 부모가 없으면 안전하게 상위로 승격 처리
                    if not current_parent_local or not current_parent_iri:
                        seq_map[r_local] += 1
                        agd_local = f"{to_agenda_base(gen, session4, round3, meeting_no)}-{seq_map[r_local]:03d}"
                        agd_iri   = URIRef(NADAT3[agd_local])
                        g_main.add((agd_iri, RDF.type, NAM3.AgendaItem))
                        g_main.add((agd_iri, SKOS.prefLabel, Literal(f"[{agd_local}] {main_label}", lang="ko")))
                        pure_title = extract_pure_agenda_title(raw_item)
                        g_main.add((agd_iri, DCTERMS.title, Literal(pure_title, lang="ko")))
                        g_main.add((agd_iri, DCTERMS.source, URIRef(r_iri)))
                        g_main.add((agd_iri, DCTERMS.isPartOf, URIRef(act_iri)))
                        if is_alt:
                            g_main.add((agd_iri, RDFS.comment, Literal("대안", lang="ko")))
                        if starts_with_digit(raw_item):
                            g_subj.add((URIRef(r_iri), RICO.hasOrHadSubject, agd_iri))
                        if bill_no:
                            if is_alt:
                                alt_bill_iri = ensure_alt_bill_defined(g_main, bill_no)
                                g_main.add((agd_iri, DCTERMS.subject, alt_bill_iri))
                                if submitter_iri:
                                    sid = f"BILL-ALT-{bill_no}"
                                    if str(URIRef(submitter_iri)) not in pre_creators.get(sid, set()) and \
                                       (alt_bill_iri, SCHEMA.creator, URIRef(submitter_iri)) not in g_main:
                                        g_main.add((alt_bill_iri, SCHEMA.creator, URIRef(submitter_iri)))
                            else:
                                bill_iri = ensure_bill_defined(g_main, bill_no)
                                g_main.add((agd_iri, DCTERMS.subject, bill_iri))
                                if submitter_iri:
                                    sid = f"BILL-{bill_no}"
                                    if str(URIRef(submitter_iri)) not in pre_creators.get(sid, set()) and \
                                       (bill_iri, SCHEMA.creator, URIRef(submitter_iri)) not in g_main:
                                        g_main.add((bill_iri, SCHEMA.creator, URIRef(submitter_iri)))
                        # 새 부모로 설정 (다음 sub들을 받을 수 있게)
                        current_parent_local = agd_local
                        current_parent_iri   = agd_iri
                        sub_seq_map.setdefault(current_parent_local, 0)
                        continue

                    # 정상적인 하위안건 처리
                    sub_seq_map[current_parent_local] += 1
                    child_local = f"{current_parent_local}-{sub_seq_map[current_parent_local]:03d}"
                    child_iri   = URIRef(NADAT3[child_local])

                    g_main.add((child_iri, RDF.type, NAM3.AgendaItem))
                    g_main.add((child_iri, SKOS.prefLabel, Literal(f"[{child_local}] {main_label}", lang="ko")))
                    pure_title = extract_pure_agenda_title(raw_item)
                    g_main.add((child_iri, DCTERMS.title, Literal(pure_title, lang="ko")))
                    g_main.add((child_iri, DCTERMS.source, URIRef(r_iri)))
                    g_main.add((child_iri, DCTERMS.isPartOf, current_parent_iri))  # ★ 하위→상위 연결
                    if is_alt:
                        g_main.add((child_iri, RDFS.comment, Literal("대안", lang="ko")))
                    # 하위안건은 보통 숫자로 시작 X → 기존 규칙 유지
                    if starts_with_digit(raw_item):
                        g_subj.add((URIRef(r_iri), RICO.hasOrHadSubject, child_iri))
                    # Bill 연결(+ creator)
                    if bill_no:
                        if is_alt:
                            alt_bill_iri = ensure_alt_bill_defined(g_main, bill_no)
                            g_main.add((child_iri, DCTERMS.subject, alt_bill_iri))
                            if submitter_iri:
                                sid = f"BILL-ALT-{bill_no}"
                                if str(URIRef(submitter_iri)) not in pre_creators.get(sid, set()) and \
                                   (alt_bill_iri, SCHEMA.creator, URIRef(submitter_iri)) not in g_main:
                                    g_main.add((alt_bill_iri, SCHEMA.creator, URIRef(submitter_iri)))
                        else:
                            bill_iri = ensure_bill_defined(g_main, bill_no)
                            g_main.add((child_iri, DCTERMS.subject, bill_iri))
                            if submitter_iri:
                                sid = f"BILL-{bill_no}"
                                if str(URIRef(submitter_iri)) not in pre_creators.get(sid, set()) and \
                                   (bill_iri, SCHEMA.creator, URIRef(submitter_iri)) not in g_main:
                                    g_main.add((bill_iri, SCHEMA.creator, URIRef(submitter_iri)))

        except Exception as e:
            print(f"[WARN] row skipped due to error: {e}")

    # 저장
    out_main = Path(out_ttl_d3); out_main.parent.mkdir(parents=True, exist_ok=True)
    g_main.serialize(destination=out_main.as_posix(), format="turtle")
    print(f"[write] Agenda & Bill TTL: {out_main}")

    out_subj = Path(out_ttl_subject); out_subj.parent.mkdir(parents=True, exist_ok=True)
    g_subj.serialize(destination=out_subj.as_posix(), format="turtle")
    print(f"[write] Record hasOrHadSubject TTL: {out_subj}")

    if prov.created:
        Path(out_tmp_people).parent.mkdir(parents=True, exist_ok=True)
        prov.write_ttl(out_tmp_people)
        print(f"[write] Provisional persons TTL: {out_tmp_people}")
    else:
        Path(out_tmp_people).write_text("# No provisional persons were created.\n", encoding="utf-8")
        print(f"[write] No provisional persons. Wrote a placeholder: {out_tmp_people}")

if __name__ == "__main__":
    convert(
        CSV_PATH,
        OUT_TTL_D3,
        OUT_TTL_SUBJECT,
        OUT_TMP_PEOPLE,
        encoding=CSV_ENCODING,
        people_ttl=PEOPLE_TTL
    )
