import re
import pandas as pd
from datetime import date
from pathlib import Path
from typing import Dict, Optional, Tuple, List

from rdflib import Graph, Literal, URIRef, Namespace
from rdflib.namespace import RDF, RDFS, SKOS, DCTERMS, XSD, FOAF, OWL

CSV_PATH       = r"D:/연구/국회회의록/21대_본회의_new_1.csv"             # 입력 CSV 파일
OUT_TTL        = r"m1_records_add_PS.txt"                                    # d1: 출력 TTL
PEOPLE_TTL     = r"https://lseun135.github.io/NAontology_study/resource/d2-person.ttl"
OUT_TMP_PEOPLE = r"m2_persons_tmp_add_1.txt"                                 # (신규) 임시 Person TTL(txt)
CSV_ENCODING   = "utf-8-sig"

# ---- Namespaces ----
NAM1   = Namespace("https://lseun135.github.io/NAontology_study/m1-record#")
NAM2   = Namespace("https://lseun135.github.io/NAontology_study/m2-person#")
NAM3   = Namespace("https://lseun135.github.io/NAontology_study/m3-content#")

NADAT1 = Namespace("https://lseun135.github.io/NAontology_study/resource/d1-record#")
NADAT2 = Namespace("https://lseun135.github.io/NAontology_study/resource/d2-person#")
NADAT3 = Namespace("https://lseun135.github.io/NAontology_study/resource/d3-content#")

RICO   = Namespace("https://www.ica.org/standards/RiC/ontology#")
ORG    = Namespace("http://www.w3.org/ns/org#")
SCHEMA = Namespace("https://schema.org/")

# ---- 숫자/날짜 유틸 ----
def digits_only(s):
    if s is None or (isinstance(s, float) and pd.isna(s)): return None
    m = re.findall(r"\d+", str(s))
    return int("".join(m)) if m else None

def pad(n, width):
    return f"{n:0{width}d}" if n is not None else None

def parse_date_simple(s):
    if s is None or (isinstance(s, float) and pd.isna(s)): return None
    nums = re.findall(r"\d+", str(s))
    if len(nums) >= 3:
        y, m, d = int(nums[0]), int(nums[1]), int(nums[2])
        if 1 <= m <= 12 and 1 <= d <= 31:
            return y, m, d
    return None

# ---- RDF 헬퍼 ----
def add_lit(g, s, p, value, lang=None, dt=None):
    if value is None or (isinstance(value, float) and pd.isna(value)): return
    g.add((s, p, Literal(value, lang=lang, datatype=dt)))

def add_res(g, s, p, iri_str):
    if not iri_str: return
    g.add((s, p, URIRef(iri_str)))

# ---- d2-person.ttl → 이름 인덱스(원형/공백제거) ----
def build_person_index_from_ttl(people_ttl_url):
    idx_exact, idx_nospace = {}, {}
    if not people_ttl_url: return idx_exact, idx_nospace
    gp = Graph()
    gp.parse(people_ttl_url, format="turtle")

    tmp = {}
    def collect(o_lit, s):
        if isinstance(o_lit, Literal) and (o_lit.language in ("ko", None)):
            name = str(o_lit).strip()
            if name:
                tmp.setdefault(name, set()).add(str(s))

    for s, o in gp.subject_objects(FOAF.name):  collect(o, s)
    for s, o in gp.subject_objects(RDFS.label): collect(o, s)

    for name, iris in tmp.items():
        if len(iris) == 1:
            iri = next(iter(iris))
            idx_exact[name] = iri
            idx_nospace[name.replace(" ", "")] = iri
    return idx_exact, idx_nospace

# ---- 발언자 파서(공백 토큰 기반) ----
_BRACKETS = [r"\(.*?\)", r"\[.*?\)", r"【.*?】", r"〈.*?〉", r"《.*?》", r"「.*?」", r"『.*?』"]

def _strip_brackets_spaces(text: str) -> str:
    t = text
    for pat in _BRACKETS: t = re.sub(pat, "", t)
    return re.sub(r"\s+", " ", t).strip()

def _candidate_names(tokens: List[str]):
    cands = []
    n = len(tokens)
    for i in range(n):
        cands.append(([i], tokens[i]))                        # 단일 토큰
        if i + 1 < n: cands.append(([i, i+1], tokens[i]+tokens[i+1]))  # 연속 2토큰 결합
    return cands

def parse_speaker_name(raw, idx_exact, idx_nospace):
    if raw is None or (isinstance(raw, float) and pd.isna(raw)): return None, None, None, None
    original = str(raw)
    txt = _strip_brackets_spaces(original)
    if not txt: return None, None, None, original
    tokens = txt.split()
    if not tokens: return None, None, None, original

    for used_idx, cand in _candidate_names(tokens):
        iri = idx_exact.get(cand) or idx_nospace.get(cand.replace(" ", ""))
        if iri:
            role_tokens = [t for i, t in enumerate(tokens) if i not in used_idx]
            role_text = " ".join(role_tokens) if role_tokens else None
            return cand, iri, role_text, original
    return None, None, None, original  # 사전에 없으면 연결 생략

# ================== 여기부터 추가: 직책 제거 규칙 & 이름만 추출 ==================
# 업로드 샘플에서 확인된 직책군을 반영 (사무총장/의사국장/대통령/국무총리/부총리겸…장관/…차관/…청장/
# 위원장(대리·직무대행)·위원·의원 등)  :contentReference[oaicite:1]{index=1}
ROLE_KWS = {
    "대통령","국무총리","총리","부총리","부총리겸","의장","부의장","의원","위원","간사",
    "위원장","위원장대리","위원장직무대행","위원장직무대리",
    "대변인","차관","장관","청장","총장","국장","과장","실장","소장","원장",
    "처장","본부장","센터장","팀장","단장","사무총장","의사국장","직무대리","직무대행"
}

# 복합 직함 포괄(예: '부총리겸기획재정부장관', '외교부장관직무대리', '여성가족위원장대리' 등)
ROLE_SUFFIX_RE = re.compile(
    r"(?:[가-힣A-Za-z·\-]+)?("
    r"대통령|국무총리|총리|부총리(?:겸)?|"
    r"장관|차관|청장|총장|국장|과장|실장|소장|원장|처장|본부장|센터장|팀장|단장|"
    r"의장|부의장|의원|위원장(?:대리|직무대행|직무대리)?|위원|"
    r"직무대리|직무대행"
    r")$"
)

# 한국어 이름(공백 없이 2~4자 한글) 우선
KOREAN_NAME_RE = re.compile(r"^[가-힣]{2,4}$")

def extract_name_only_from_speaker(raw_text: str) -> Optional[str]:
    """
    '이름 직책' 또는 '직책 이름' 혼재 셀에서 '이름'만 추출.
    - 괄호류 제거 → 공백 분리
    - 직책(키워드/접미 패턴) 토큰 제거
    - 남은 토큰 중 한국어 인명(2~4자) 우선 선택
    """
    if not raw_text:
        return None
    cleaned = _strip_brackets_spaces(str(raw_text))
    if not cleaned:
        return None

    tokens = cleaned.split()
    personish = []
    for t in tokens:
        t_norm = t.strip()
        if (t_norm in ROLE_KWS) or ROLE_SUFFIX_RE.search(t_norm):
            continue
        personish.append(t_norm)

    # 우선: 2~4자 한글 이름
    for t in personish:
        if KOREAN_NAME_RE.match(t):
            return t

    # 보강: 2~5자 한글 중 가장 짧은 것
    alt = [t for t in personish if re.fullmatch(r"[가-힣]{2,5}", t)]
    if alt:
        return sorted(alt, key=len)[0]

    # 최후: 마지막 토큰
    return personish[-1] if personish else (tokens[-1] if tokens else None)
# ================== 추가 끝 ==================

# ---- 임시 Person 관리 ----
class ProvisionalPersonManager:
    """
    CSV에 등장하지만 d2-person.ttl에 없는 사람을
    등장 순서대로 PER-TMP-00001, 00002... 형태로 부여하고,
    나중에 TTL(txt)로 한꺼번에 기록한다.
    """
    def __init__(self):
        self.counter = 0
        # '이름만' 기준으로 중복 방지
        self.name_to_iri: Dict[str, str] = {}
        self.entries: List[Tuple[str, str]] = []  # (iri_local, name_only)

    @staticmethod
    def _norm_key(name_text: str) -> str:
        return (name_text or "").replace(" ", "")

    def get_or_create(self, speaker_cell_text: str) -> Optional[str]:
        """
        speaker_cell_text: CSV '발언자' 원문
        반환: NADAT2[...] 형태의 IRI 문자열
        """
        if not speaker_cell_text:
            return None

        # 이름만 추출해 사용
        name_only = extract_name_only_from_speaker(speaker_cell_text)
        if not name_only:
            name_only = _strip_brackets_spaces(speaker_cell_text)

        key = self._norm_key(name_only)
        if key in self.name_to_iri:
            return self.name_to_iri[key]

        self.counter += 1
        local_id = f"PER-TMP-{self.counter:05d}"
        iri_str = str(NADAT2[local_id])
        self.name_to_iri[key] = iri_str
        # TTL에 기록될 라벨/이름 = '이름만'
        self.entries.append((local_id, name_only))
        return iri_str

    def write_ttl_txt(self, out_path: str):
        """
        요구 예시 스타일에 가깝게 TTL(txt)로 출력한다.
        """
        out_file = Path(out_path).expanduser().resolve()
        out_file.parent.mkdir(parents=True, exist_ok=True)

        lines = []
        # prefix 선언 (TTL 파서가 바로 읽도록)
        lines.append('@prefix foaf:  <http://xmlns.com/foaf/0.1/> .')
        lines.append('@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .')
        lines.append('@prefix nam2:  <https://lseun135.github.io/NAontology_study/m2-person#> .')
        lines.append('@prefix nadat2: <https://lseun135.github.io/NAontology_study/resource/d2-person#> .')
        lines.append('')
        lines.append('## 임시개체')
        lines.append('')

        for local_id, name_only in self.entries:
            lines.append(f"nadat2:{local_id} a foaf:Person ;")
            lines.append(f'\trdfs:label "{name_only}"@ko ;')
            lines.append(f'\tfoaf:name "{name_only}"@ko ;')
            lines.append(f"\tnam2:isInAStateOf nam2:Provisional .")
            lines.append('')

        with out_file.open("w", encoding="utf-8") as f:
            f.write("\n".join(lines))

        print(f"[write] provisional persons txt: {out_file} (count={len(self.entries)})")

# ---- 메인 변환 ----
def convert(csv_path, out_path, tmp_people_out_path,
            encoding="utf-8-sig", people_ttl_url=None):
    df = pd.read_csv(csv_path, encoding=encoding)

    g = Graph()
    # prefix 바인딩
    g.bind("rdf", RDF); g.bind("rdfs", RDFS); g.bind("skos", SKOS)
    g.bind("dcterms", DCTERMS); g.bind("xsd", XSD); g.bind("foaf", FOAF); g.bind("owl", OWL)
    g.bind("rico", RICO); g.bind("org", ORG); g.bind("schema", SCHEMA)
    g.bind("nam1", NAM1); g.bind("nam2", NAM2); g.bind("nam3", NAM3)
    g.bind("nadat1", NADAT1); g.bind("nadat2", NADAT2); g.bind("nadat3", NADAT3)

    # 사람 인덱스
    idx_exact, idx_nospace = build_person_index_from_ttl(people_ttl_url) if people_ttl_url else ({}, {})
    print(f"[info] loaded persons: exact={len(idx_exact)}, nospace={len(idx_nospace)}")

    prov_mgr = ProvisionalPersonManager()
    seen_participants: Dict[str, set] = {}
    total_rows = 0
    linked_count = 0
    provisional_linked = 0

    for _, row in df.iterrows():
        total_rows += 1

        mtg_no = int(row["회의번호"]) if not pd.isna(row["회의번호"]) else None
        if mtg_no is None: continue

        generation = int(row["대수"]) if not pd.isna(row["대수"]) else None
        rec_type   = str(row.get("회의록구분") or "").strip()
        meeting_tp = str(row.get("회의구분") or "").strip()
        committee  = str(row.get("위원회") or "").strip()
        session_raw = row.get("회수")
        round_raw   = row.get("차수")
        date_raw    = row.get("회의일자")

        session_num = digits_only(session_raw)
        session4    = pad(session_num, 4)
        round_num   = digits_only(round_raw)
        round3      = pad(round_num, 3)

        # 1) Activity (회의번호)
        act = URIRef(NADAT1[f"ACT-M-{mtg_no}"])
        g.add((act, RDF.type, RICO.Activity))
        add_lit(g, act, RICO.identifier, f"ACT-M-{mtg_no}")
        label_act = f"[ACT-M-{mtg_no}]"
        if generation is not None: label_act += f" {generation}대"
        if rec_type:               label_act += f" {rec_type}"
        if meeting_tp:             label_act += f" {meeting_tp}"
        if session_raw and str(session_raw).strip(): label_act += f" {str(session_raw).strip()}"
        if round_raw and str(round_raw).strip():     label_act += f" {str(round_raw).strip()}"
        add_lit(g, act, SKOS.prefLabel, label_act, lang="ko")
        add_lit(g, act, RICO.name, f"제{generation}대 {rec_type} {meeting_tp} {session_raw} {round_raw}", lang="ko")
        add_lit(g, act, DCTERMS.identifier, f"{mtg_no}")
        add_res(g, act, RICO.hasActivityType, str(NAM1["PlenarySession"]))
        add_res(g, act, RICO.isOrWasPerformedBy, str(NADAT2["NationalAssembly"]))
       
        

        # 2) RecordSet S(대수)
        s_node = None
        if generation is not None:
            s_node = URIRef(NADAT1[f"S1000{generation}PS"])
            g.add((s_node, RDF.type, RICO.RecordSet))
            add_lit(g, s_node, RICO.identifier, f"S1000{generation}PS")
            s_label = f"[S1000{generation}PS] {generation}대"
            if rec_type:   s_label += f" {rec_type}"
            if meeting_tp: s_label += f" {meeting_tp}"
            add_lit(g, s_node, SKOS.prefLabel, s_label, lang="ko")
            add_lit(g, s_node, RICO.classification, "A")
            add_lit(g, s_node, RICO.name, f"제{generation}대 {rec_type} {meeting_tp}", lang="ko")

        # 3) RecordSet F(회수)
        f_node = None
        if generation is not None and session4 is not None:
            f_node = URIRef(NADAT1[f"F1000{generation}{session4}PS"])
            g.add((f_node, RDF.type, RICO.RecordSet))
            add_lit(g, f_node, RICO.identifier, f"F1000{generation}{session4}PS")
            f_label = f"[F{session4}PS]"
            if generation is not None: f_label += f" {generation}대"
            if meeting_tp:             f_label += f" {meeting_tp}"
            if session_raw and str(session_raw).strip(): f_label += f" {str(session_raw).strip()}"
            add_lit(g, f_node, SKOS.prefLabel, f_label, lang="ko")
            add_lit(g, f_node, RICO.name, f"제{generation}대 {rec_type} {meeting_tp} {session_raw}", lang="ko")
            add_lit(g, f_node, RICO.classification, "A")
            add_lit(g, f_node, RICO.conditionsOfAccess, "공개", lang="ko")
            add_lit(g, f_node, RICO.conditionsOfAccess, "Open", lang="en")
            add_lit(g, f_node, RICO.conditionsOfUse,
                    "공공누리 제3유형 (출처표시 + 변경금지) 조건에 따라 자유롭게 이용이 가능합니다.", lang="ko")
            add_res(g, f_node, RICO.hasContentOfType, str(NAM1["text"]))
            add_res(g, f_node, RICO.hasOrHadLegalStatus, str(NAM1["public"]))
            if s_node is not None:
                g.add((s_node, RICO.includesOrIncluded, f_node))

        # 4) Record R(차수)
        r_node = None
        if generation is not None and session4 is not None and round3 is not None:
            r_node = URIRef(NADAT1[f"R1000{generation}{session4}{round3}{mtg_no}"])
            g.add((r_node, RDF.type, RICO.Record))
            add_lit(g, r_node, RICO.identifier, f"R1000{generation}{session4}{round3}{mtg_no}")
            r_label = f"[R1000{generation}{session4}{round3}{mtg_no}] {generation}대"
            if session_raw and str(meeting_tp).strip(): r_label += f" {str(meeting_tp).strip()}"            
            if session_raw and str(session_raw).strip(): r_label += f" {str(session_raw).strip()}"   # 
            if round_raw and str(round_raw).strip():     r_label += f" {str(round_raw).strip()} 회의록"
            add_lit(g, r_node, SKOS.prefLabel, r_label, lang="ko")

            title = ""
            if session_num is not None: title += f"제{session_num}회국회 "
            if committee:               title += f"{committee}회의록 "
            if round_num is not None:   title += f"제 {round_num} 호"
            add_lit(g, r_node, RICO.title, title.strip(), lang="ko")

            add_lit(g, r_node, RICO.classification, "A")
            g.add((r_node, RICO.documents, act))

            if f_node is not None:
                g.add((f_node, RICO.includesOrIncluded, r_node))
                
            add_lit(g, r_node, RICO.conditionsOfAccess, "공개", lang="ko")
            add_lit(g, r_node, RICO.conditionsOfAccess, "Open", lang="en")
            add_lit(g, r_node, RICO.conditionsOfUse,
                    "공공누리 제3유형 (출처표시 + 변경금지) 조건에 따라 자유롭게 이용이 가능합니다.", lang="ko")
            add_res(g, r_node, RICO.hasContentOfType, str(NAM1["text"]))
            add_res(g, r_node, RICO.hasOrHadLegalStatus, str(NAM1["public"]))
            add_res(g, r_node, RICO.hasOrHadLanguage, str(NAM1["lang-kor"]))

            ymd = parse_date_simple(date_raw)
            if ymd:
                y, m, d = ymd
                date_iri = str(NADAT1[f"date-{y:04d}_{m:02d}_{d:02d}"])
                d_node = URIRef(date_iri)
                g.add((d_node, RDF.type, RICO.Date))
                local = f"date-{y:04d}_{m:02d}_{d:02d}"
                add_lit(g, d_node, RICO.identifier, local)
                add_lit(g, d_node, RICO.name, local)
                add_lit(g, d_node, RICO.normalizedDateValue, date(y, m, d).isoformat(), dt=XSD.date)
                if isinstance(date_raw, str) and date_raw.strip():
                    add_lit(g, d_node, RICO.expressedDate, str(date_raw).strip(), lang="ko")
                add_res(g, d_node, RICO.hasDateType, str(NAM1["singleDate"]))
                add_res(g, r_node, RICO.hasCreationDate, date_iri)
                
                # Date → Activity(Event) (도메인: Date, 레인지: Activity)
                g.add((URIRef(date_iri), RICO.isDateOfOccurrenceOf, act))

        # 5) Participants (발언자 → ACT) + 임시개체 처리
        name, iri, role, original_speaker = parse_speaker_name(row.get("발언자"), idx_exact, idx_nospace)

        if iri:
            # 기존 d2에 있던 사람
            key = f"ACT-M-{mtg_no}"
            seen_participants.setdefault(key, set())
            if iri not in seen_participants[key]:
                seen_participants[key].add(iri)
                add_res(g, act, RICO.hasOrHadParticipant, iri)
                linked_count += 1
        else:
            # d2에 없음 → 임시개체 생성 및 연결 (이름만을 기준으로 생성)
            speaker_text_for_label = original_speaker if original_speaker else row.get("발언자")
            tmp_iri = prov_mgr.get_or_create(speaker_text_for_label)
            if tmp_iri:
                key = f"ACT-M-{mtg_no}"
                seen_participants.setdefault(key, set())
                if tmp_iri not in seen_participants[key]:
                    seen_participants[key].add(tmp_iri)
                    add_res(g, act, RICO.hasOrHadParticipant, tmp_iri)
                    provisional_linked += 1

    # 저장(d1)
    out_file = Path(out_path).expanduser().resolve()
    out_file.parent.mkdir(parents=True, exist_ok=True)
    g.serialize(destination=out_file.as_posix(), format="turtle")
    print(f"[done] rows={total_rows}, participants_linked(existing)={linked_count}, provisional_linked={provisional_linked}")
    print(f"[write] {out_file}")

    # 저장(임시 Person TTL txt, d2 보완용)
    prov_mgr.write_ttl_txt(tmp_people_out_path)

# ==== 실행 ====
if __name__ == "__main__":
    convert(CSV_PATH, OUT_TTL, OUT_TMP_PEOPLE, encoding=CSV_ENCODING, people_ttl_url=PEOPLE_TTL)


          
