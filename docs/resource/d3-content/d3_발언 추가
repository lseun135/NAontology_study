import re
import pandas as pd
from pathlib import Path
from typing import Optional, List, Dict, Tuple, Set
from rdflib import Graph, Literal, URIRef, Namespace
from rdflib.namespace import RDF, RDFS, SKOS, DCTERMS, FOAF, XSD

# ========================= CONFIG =========================
CSV_PATH          = r"C:/Users/LSE/Desktop/논문주제뭐하지/ontology/본회의1차수샘플.csv"
CSV_ENCODING      = "utf-8-sig"

# (필수) 기존 AgendaItem/Bill이 들어있는 TTL: dcterms:title & dcterms:source 기반 매핑
PRELOADED_D3_TTL  = r"https://lseun135.github.io/NAontology_study/resource/d3-content.ttl"

# 출력
OUT_TTL_SPEECH    = r"d3_speech_add_1.txt"     # Speech 본문 TTL
OUT_TMP_PEOPLE    = r"d2_person_tmp_add_4.txt"

# (이름 확인)
PEOPLE_TTL        = r"https://lseun135.github.io/NAontology_study/resource/d2-person.ttl"

# ========================= NAMESPACES =========================
NAM3   = Namespace("https://lseun135.github.io/NAontology_study/m3-content#")
NADAT1 = Namespace("https://lseun135.github.io/NAontology_study/resource/d1-record#")
NADAT2 = Namespace("https://lseun135.github.io/NAontology_study/resource/d2-person#")
NADAT3 = Namespace("https://lseun135.github.io/NAontology_study/resource/d3-content#")
RICO   = Namespace("https://www.ica.org/standards/RiC/ontology#")
SCHEMA = Namespace("https://schema.org/")

# ========================= 유틸 =========================
def digits_only(s) -> Optional[int]:
    if s is None or (isinstance(s, float) and pd.isna(s)): return None
    m = re.findall(r"\d+", str(s))
    return int("".join(m)) if m else None

def pad(n: Optional[int], width: int) -> Optional[str]:
    return f"{n:0{width}d}" if n is not None else None

def to_r_id(gen: int, session4: str, round3: str, meeting_no: int) -> str:
    # 예: R100021041400253844
    return f"R1000{gen}{session4}{round3}{meeting_no}"

def to_speech_base(gen: int, session4: str, round3: str, meeting_no: int) -> str:
    # 예: SPH-R100021041400253844
    return f"SPH-R1000{gen}{session4}{round3}{meeting_no}"

# ---------- 안건 분리 (Agenda 때와 동일 규칙) ----------
_BULLET_OR_O_RE = re.compile(r'(?<!\d)(\d+)\.\s*|[o○]\s+', re.MULTILINE)
def split_agenda_cell(cell: str) -> List[str]:
    if cell is None or (isinstance(cell, float) and pd.isna(cell)):
        return []
    text = str(cell).strip()
    if not text: return []
    starts = [m.start() for m in _BULLET_OR_O_RE.finditer(text)]
    if not starts: return [text]
    if starts[0] != 0: starts = [0] + starts
    parts = []
    for i, s in enumerate(starts):
        e = starts[i+1] if i+1 < len(starts) else len(text)
        seg = text[s:e].strip()
        if seg: parts.append(seg)
    return parts

# ---------- 타이틀 정규화(공백만) ----------
def normalize_title(s: str) -> str:
    # 번호/기호(o/○) 포함 원문을 유지 — 공백만 정규화
    return re.sub(r"\s+", " ", str(s or "")).strip()

# ---------- nadat2 인물 인덱스 & 임시 생성 ----------
def build_person_index_by_rdfs_label(people_ttl: Optional[str]) -> Dict[str, str]:
    idx = {}
    if not people_ttl: return idx
    g = Graph()
    try: g.parse(people_ttl, format="turtle")
    except Exception: return idx
    for s in set(g.subjects(RDF.type, FOAF.Person)):
        for o in g.objects(s, RDFS.label):
            if isinstance(o, Literal):
                lab = str(o).strip()
                if lab: idx[lab] = str(s)
    return idx

def get_existing_prov_start(people_ttl: Optional[str]) -> int:
    if not people_ttl: return 0
    try:
        g = Graph(); g.parse(people_ttl, format="turtle")
        pat = re.compile(r"(?:/|#)PER\-TMP\-(\d{5})$")
        mx = 0
        for s in g.subjects():
            if isinstance(s, URIRef):
                m = pat.search(str(s))
                if m: mx = max(mx, int(m.group(1)))
        return mx
    except Exception:
        return 0

STOPWORDS_NONPERSON = {"정부","국회","정부위원"}  # 비인명 필터

class ProvisionalPeople:
    def __init__(self, start_from: int = 0):
        self.counter = start_from
        self.created: List[Tuple[str,str]] = []   # (local_id, label)
        self._label2iri: Dict[str,str] = {}

    def mint(self, label_ko: str) -> Optional[str]:
        key = (label_ko or "").strip()
        if not key or key in STOPWORDS_NONPERSON:
            return None
        if key in self._label2iri:
            return self._label2iri[key]
        self.counter += 1
        local = f"PER-TMP-{self.counter:05d}"
        iri = str(NADAT2[local])
        self.created.append((local, key))
        self._label2iri[key] = iri
        return iri

    def write_ttl(self, path: str):
        out = Path(path); out.parent.mkdir(parents=True, exist_ok=True)
        lines = []
        lines.append('@prefix foaf:  <http://xmlns.com/foaf/0.1/> .')
        lines.append('@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .')
        lines.append('@prefix nam2:  <https://lseun135.github.io/NAontology_study/m2-person#> .')
        lines.append('@prefix nadat2: <https://lseun135.github.io/NAontology_study/resource/d2-person#> .')
        lines.append('')
        lines.append('## 임시 개체 (발언자 이름 확인 시에만 생성)')
        lines.append('')
        for local, label in self.created:
            lines.append(f"nadat2:{local} a foaf:Person ;")
            lines.append(f'\trdfs:label "{label}"@ko ;')
            lines.append(f'\tfoaf:name "{label}"@ko ;')
            lines.append(f"\tnam2:isInAStateOf nam2:Provisional .")
            lines.append('')
        out.write_text("\n".join(lines), encoding="utf-8")

# ---------- (R IRI, dcterms:title) → AGD IRI 인덱스 ----------
def build_agenda_title_index_from_d3(d3_ttl_path: str) -> Dict[Tuple[str,str], str]:
    """
    d3_content_add_AB_x.txt에서:
      - dcterms:source (R IRI)
      - dcterms:title  (CSV 원문 안건, 번호/기호 포함)
    를 키로 하여 AgendaItem IRI를 찾는 인덱스를 만든다.
    """
    g = Graph(); g.parse(d3_ttl_path, format="turtle")
    idx: Dict[Tuple[str,str], str] = {}
    for agd in set(g.subjects(RDF.type, NAM3.AgendaItem)):
        r_iri = None
        for o in g.objects(agd, DCTERMS.source):
            if isinstance(o, URIRef):
                r_iri = str(o); break
        if not r_iri:
            continue
        for o in g.objects(agd, DCTERMS.title):
            if isinstance(o, Literal):
                title = normalize_title(str(o))
                if title:
                    idx[(r_iri, title)] = str(agd)
    return idx

# ---------- 합쳐진 "발언자" 문자열에서 이름/직책 분리 ----------
ROLE_WORDS = {"의장","부의장","의원","장관","차관","위원장","간사","대변인","검사","총장","위원"}
def split_role_name_combined(cell_val: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
    """
    입력 예: '의장 김진표' / '법무부장관 박성재' / '유상범 의원' / '김진표' / '정부위원 이모씨'
    반환: (이름, 직책)  # 둘 다 없을 수 있음
    """
    if not cell_val or (isinstance(cell_val, float) and pd.isna(cell_val)):
        return None, None
    s = re.sub(r"\s+", " ", str(cell_val)).strip()

    # 패턴1: '이름 직책' (이름 뒤에 역할)
    m = re.match(r"^([가-힣]{2,4})\s*(의장|부의장|의원|장관|차관|위원장|간사|대변인|검사|총장|위원)$", s)
    if m: return m.group(1), m.group(2)

    # 패턴2: '직책(부처 포함) 이름'
    m = re.match(r"^(.*?(의장|부의장|장관|차관|위원장|간사|대변인|검사|총장|위원))\s*([가-힣]{2,4})$", s)
    if m:
        role = m.group(1).strip()
        name = m.group(3).strip()
        return name, role

    # 패턴3: '이름'만
    m = re.match(r"^([가-힣]{2,4})$", s)
    if m: return m.group(1), None

    # 패턴4: 토큰 스캔
    toks = s.split()
    name, role = None, None
    for t in toks:
        if t in ROLE_WORDS or t.endswith("장") or t.endswith("의원") or t.endswith("위원"):
            role = role or t
        elif re.fullmatch(r"[가-힣]{2,4}", t):
            name = name or t
    return name, role

# ================= 메인 변환 =================
def convert(csv_path: str,
            preloaded_d3_ttl: str,
            out_ttl_speech: str,
            out_tmp_people: str,
            encoding: str = "utf-8-sig",
            people_ttl: Optional[str] = None):

    # --- CSV ---
    df = pd.read_csv(csv_path, encoding=encoding)

    # --- 그래프 ---
    g = Graph()
    for pfx, ns in [("rdf", RDF), ("rdfs", RDFS), ("skos", SKOS), ("dcterms", DCTERMS),
                    ("foaf", FOAF), ("xsd", XSD), ("rico", RICO), ("schema", SCHEMA),
                    ("nam3", NAM3), ("nadat1", NADAT1), ("nadat2", NADAT2), ("nadat3", NADAT3)]:
        g.bind(pfx, ns)

    # --- 인물 인덱스 & 임시 시작값 ---
    person_idx = build_person_index_by_rdfs_label(people_ttl)
    prov_start = get_existing_prov_start(people_ttl)
    prov = ProvisionalPeople(start_from=prov_start)

    # --- (R IRI, title) → AGD IRI 인덱스 (필수) ---
    agd_title_idx = build_agenda_title_index_from_d3(preloaded_d3_ttl)

    # --- R별 Speech 시퀀스 (4자리, 발언순번이 없을 때만 사용) ---
    seq_map: Dict[str,int] = {}

    # 고정(또는 탐색) 헤더
    COL_AGENDA   = "안건"
    # 이름/직책이 분리돼 있는 경우도 대비
    COL_SPEAKER_NAME = "발언자(이름)"
    COL_SPEAKER_ROLE = "발언자(직책)"
    # 합쳐진 원본이 들어오는 경우의 후보 헤더명(있으면 사용)
    COMBINED_CANDIDATES = ["발언자", "발언자(이름)"]

    COL_POS      = "발언순번"
    COL_TEXT     = "발언내용"
    COL_ID       = "의원ID"
    COL_GEN      = "대수"
    COL_SES      = "회수"
    COL_ROUND    = "차수"
    COL_MEETNO   = "회의번호"

    # CSV에 어떤 스피커 컬럼이 있는지 확인
    has_split = (COL_SPEAKER_NAME in df.columns) and (COL_SPEAKER_ROLE in df.columns)
    combined_col = None
    if not has_split:
        for c in COMBINED_CANDIDATES:
            if c in df.columns:
                combined_col = c
                break

    for _, row in df.iterrows():
        try:
            gen        = int(row[COL_GEN]) if not pd.isna(row[COL_GEN]) else None
            session4   = pad(digits_only(row[COL_SES]), 4)
            round3     = pad(digits_only(row[COL_ROUND]), 3)
            meeting_no = int(row[COL_MEETNO]) if not pd.isna(row[COL_MEETNO]) else None
            if not (gen and session4 and round3 and meeting_no):
                continue

            r_local = to_r_id(gen, session4, round3, meeting_no)
            r_iri   = str(NADAT1[r_local])

            # 발언순번 → IRI suffix 우선 사용
            pos_val = row[COL_POS] if COL_POS in row else None
            pos = digits_only(pos_val)
            if pos is None:
                seq_map[r_local] = seq_map.get(r_local, 0) + 1
                pos = seq_map[r_local]
            pos4 = f"{pos:04d}"

            sph_local = f"{to_speech_base(gen, session4, round3, meeting_no)}-{pos4}"
            sph_iri   = URIRef(NADAT3[sph_local])

            # 안건(subject): 분리 → (R IRI, title) 키로 매칭
            agenda_items = split_agenda_cell(row[COL_AGENDA])
            matched_iris: List[str] = []
            for item in agenda_items:
                key = (r_iri, normalize_title(item))
                iri = agd_title_idx.get(key)
                if iri:
                    matched_iris.append(iri)

            # ===== 발언자 이름/직책 추출 =====
            name_val: Optional[str] = None
            role_val: Optional[str] = None

            if has_split:
                n_raw = row[COL_SPEAKER_NAME] if not pd.isna(row[COL_SPEAKER_NAME]) else None
                r_raw = row[COL_SPEAKER_ROLE] if not pd.isna(row[COL_SPEAKER_ROLE]) else None
                if isinstance(n_raw, str) and isinstance(r_raw, str) and n_raw.strip()=="" and r_raw.strip()=="":
                    n_raw = None; r_raw = None
                if n_raw or r_raw:
                    name_val = (str(n_raw).strip() if isinstance(n_raw, str) else None) or None
                    role_val = (str(r_raw).strip() if isinstance(r_raw, str) else None) or None
                else:
                    # 분리컬럼이 있더라도 값이 없으면 combined 사용
                    if combined_col:
                        name_val, role_val = split_role_name_combined(row.get(combined_col))
            else:
                # 분리컬럼이 없으면 combined에서 파싱
                name_val, role_val = split_role_name_combined(row.get(combined_col) if combined_col else None)

            # schema:creator — 이름이 있고 d2에 없으면, 의원ID가 공란일 때만 임시 생성
            creator_iri = None
            if name_val and name_val not in STOPWORDS_NONPERSON:
                creator_iri = person_idx.get(name_val)
                if not creator_iri:
                    mem_id = row[COL_ID] if COL_ID in row else None
                    blank_id = (mem_id is None) or (isinstance(mem_id, float) and pd.isna(mem_id)) or (str(mem_id).strip() == "")
                    if blank_id:
                        creator_iri = prov.mint(name_val)

            # ====== Speech 작성 ======
            g.add((sph_iri, RDF.type, NAM3.Speech))
            g.add((sph_iri, DCTERMS.source, URIRef(r_iri)))

            for agd in matched_iris:
                g.add((sph_iri, DCTERMS.subject, URIRef(agd)))

            if creator_iri:
                g.add((sph_iri, SCHEMA.creator, URIRef(creator_iri)))

            if role_val:
                g.add((sph_iri, URIRef(str(NAM3) + "recordRole"), Literal(role_val, lang="ko")))

            g.add((sph_iri, SCHEMA.position, Literal(int(pos), datatype=XSD.integer)))

            txt = row[COL_TEXT]
            if txt is not None and not (isinstance(txt, float) and pd.isna(txt)):
                g.add((sph_iri, SCHEMA.text, Literal(str(txt), lang="ko")))

        except Exception as e:
            print(f"[WARN] row skipped due to error: {e}")

    # 저장
    out_main = Path(OUT_TTL_SPEECH); out_main.parent.mkdir(parents=True, exist_ok=True)
    g.serialize(destination=out_main.as_posix(), format="turtle")
    print(f"[write] Speech TTL: {out_main}")

    # 임시 인물 저장
    if prov.created:
        Path(OUT_TMP_PEOPLE).parent.mkdir(parents=True, exist_ok=True)
        prov.write_ttl(OUT_TMP_PEOPLE)
        print(f"[write] Provisional persons TTL: {OUT_TMP_PEOPLE}")
    else:
        Path(OUT_TMP_PEOPLE).write_text("# No provisional persons were created.\n", encoding="utf-8")
        print(f"[write] No provisional persons. Wrote a placeholder: {OUT_TMP_PEOPLE}")

if __name__ == "__main__":
    convert(
        CSV_PATH,
        PRELOADED_D3_TTL,
        OUT_TTL_SPEECH,
        OUT_TMP_PEOPLE,
        encoding=CSV_ENCODING,
        people_ttl=PEOPLE_TTL
    )
