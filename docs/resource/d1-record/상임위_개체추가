import re
import io
import urllib.request
import pandas as pd
from datetime import date
from pathlib import Path
from typing import Dict, Optional, Tuple, List, Set
from collections import defaultdict

from rdflib import Graph, Literal, URIRef, Namespace
from rdflib.namespace import RDF, RDFS, SKOS, DCTERMS, XSD, FOAF, OWL


# ========================= CONFIG =========================
CSV_PATH       = r"D:/연구/국회회의록/21대_상임위_최종병합.csv"      # 입력 CSV 파일
OUT_TTL        = r"m1_records_add_SC.txt"                          # d1: 출력 TTL
PEOPLE_TTL     = r"https://lseun135.github.io/NAontology_study/resource/d2-person.ttl"
OUT_TMP_PEOPLE = r"m2_persons_tmp_add_2.txt"                       # (신규) 임시 Person TTL(txt)
CSV_ENCODING   = "utf-8-sig"

# DATE-DEDUP: 기존 d1에서 날짜 개체 인덱스 사전 적재
PRELOAD_D1_TTLS: List[str] = [r"https://lseun135.github.io/NAontology_study/resource/d1-record.ttl"]

# 디버그: 상세 로그 출력 여부
DEBUG_DATE_INDEX = True

# ======================= NAMESPACES ========================
NAM1   = Namespace("https://lseun135.github.io/NAontology_study/m1-record#")
NAM2   = Namespace("https://lseun135.github.io/NAontology_study/m2-person#")
NAM3   = Namespace("https://lseun135.github.io/NAontology_study/m3-content#")

NADAT1 = Namespace("https://lseun135.github.io/NAontology_study/resource/d1-record#")
NADAT2 = Namespace("https://lseun135.github.io/NAontology_study/resource/d2-person#")
NADAT3 = Namespace("https://lseun135.github.io/NAontology_study/resource/d3-content#")

RICO   = Namespace("https://www.ica.org/standards/RiC/ontology#")
ORG    = Namespace("http://www.w3.org/ns/org#")
SCHEMA = Namespace("https://schema.org/")

# ======================= 숫자/날짜 유틸 =======================
def digits_only(s):
    if s is None or (isinstance(s, float) and pd.isna(s)): return None
    m = re.findall(r"\d+", str(s))
    return int("".join(m)) if m else None

def pad(n, width):
    return f"{n:0{width}d}" if n is not None else None

def parse_date_simple(s):
    if s is None or (isinstance(s, float) and pd.isna(s)): return None
    nums = re.findall(r"\d+", str(s))
    if len(nums) >= 3:
        y, m, d = int(nums[0]), int(nums[1]), int(nums[2])
        if 1 <= m <= 12 and 1 <= d <= 31:
            return y, m, d
    return None

# ======================== RDF 헬퍼 ==========================
def add_lit(g, s, p, value, lang=None, dt=None):
    if value is None or (isinstance(value, float) and pd.isna(value)): return
    g.add((s, p, Literal(value, lang=lang, datatype=dt)))

def add_res(g, s, p, iri_str):
    if not iri_str: return
    g.add((s, p, URIRef(iri_str)))

# =================== d2-person.ttl → 인덱스 =================
def build_person_index_from_ttl(people_ttl_url):
    idx_exact, idx_nospace = {}, {}
    if not people_ttl_url: return idx_exact, idx_nospace
    gp = Graph()
    gp.parse(people_ttl_url, format="turtle")

    tmp = {}
    def collect(o_lit, s):
        if isinstance(o_lit, Literal) and (o_lit.language in ("ko", None)):
            name = str(o_lit).strip()
            if name:
                tmp.setdefault(name, set()).add(str(s))

    for s, o in gp.subject_objects(FOAF.name):  collect(o, s)
    for s, o in gp.subject_objects(RDFS.label): collect(o, s)

    for name, iris in tmp.items():
        if len(iris) == 1:
            iri = next(iter(iris))
            idx_exact[name] = iri
            idx_nospace[name.replace(" ", "")] = iri
    return idx_exact, idx_nospace

# 조직/조직단위 인덱스 (라벨→IRI / 라벨→org:identifier)
def build_org_index_from_ttl(people_ttl_url):
    idx = {}
    if not people_ttl_url: return idx
    gp = Graph()
    gp.parse(people_ttl_url, format="turtle")
    for s in set(list(gp.subjects(RDF.type, ORG.Organization)) +
                 list(gp.subjects(RDF.type, RICO.CorporateBody))):
        for o in gp.objects(s, SKOS.prefLabel):
            if isinstance(o, Literal) and (o.language in ("ko", None)):
                idx[str(o).strip()] = str(s)
    return idx

# OrganizationalUnit용 라벨→IRI / 라벨→identifier 동시 생성
def build_orgunit_maps(people_ttl_url) -> Tuple[Dict[str,str], Dict[str,str]]:
    label_to_iri, label_to_ident = {}, {}
    if not people_ttl_url: return label_to_iri, label_to_ident
    gp = Graph()
    gp.parse(people_ttl_url, format="turtle")
    for s in gp.subjects(RDF.type, ORG.OrganizationalUnit):
        labels = [o for o in gp.objects(s, SKOS.prefLabel) if isinstance(o, Literal) and (o.language in ("ko", None))]
        idents = [o for o in gp.objects(s, ORG.identifier) if isinstance(o, Literal)]
        ident_str = str(idents[0]).strip() if idents else None
        for lab in labels:
            lab_s = str(lab).strip()
            label_to_iri[lab_s] = str(s)
            if ident_str:
                label_to_ident[lab_s] = ident_str
    return label_to_iri, label_to_ident

# org:identifier → 식별자 접미어 변환(“CMIT”/“-” 제거)
def derive_committee_suffix_from_identifier(ident: Optional[str]) -> Optional[str]:
    if not ident:
        return None
    s = ident.replace("CMIT", "").replace("-", "").strip()
    return s or None

# ===================== 발언자 파서 유틸 =====================
_BRACKETS = [r"\(.*?\)", r"\[.*?\]", r"【.*?】", r"〈.*?〉", r"《.*?》", r"「.*?」", r"『.*?』"]

def _strip_brackets_spaces(text: str) -> str:
    t = text
    for pat in _BRACKETS: t = re.sub(pat, "", t)
    return re.sub(r"\s+", " ", t).strip()

def _candidate_names(tokens: List[str]):
    cands = []
    n = len(tokens)
    for i in range(n):
        cands.append(([i], tokens[i]))
        if i + 1 < n: cands.append(([i, i+1], tokens[i]+tokens[i+1]))
    return cands

def parse_speaker_name(raw, idx_exact, idx_nospace):
    if raw is None or (isinstance(raw, float) and pd.isna(raw)): return None, None, None, None
    original = str(raw)
    txt = _strip_brackets_spaces(original)
    if not txt: return None, None, None, original
    tokens = txt.split()
    if not tokens: return None, None, None, original

    for used_idx, cand in _candidate_names(tokens):
        iri = idx_exact.get(cand) or idx_nospace.get(cand.replace(" ", ""))
        if iri:
            role_tokens = [t for i, t in enumerate(tokens) if i not in used_idx]
            role_text = " ".join(role_tokens) if role_tokens else None
            return cand, iri, role_text, original
    return None, None, None, original

# 직책 제거 규칙 & 이름만 추출
ROLE_KWS = {
    "대통령","국무총리","총리","부총리","부총리겸","의장","부의장","의원","위원","간사",
    "위원장","위원장대리","위원장직무대행","위원장직무대리",
    "대변인","차관","장관","청장","총장","국장","과장","실장","소장","원장",
    "처장","본부장","센터장","팀장","단장","사무총장","의사국장","직무대리","직무대행"
}
ROLE_SUFFIX_RE = re.compile(
    r"(?:[가-힣A-Za-z·\-]+)?("
    r"대통령|국무총리|총리|부총리(?:겸)?|"
    r"장관|차관|청장|총장|국장|과장|실장|소장|원장|처장|본부장|센터장|팀장|단장|"
    r"의장|부의장|의원|위원장(?:대리|직무대행|직무대리)?|위원|"
    r"직무대리|직무대행"
    r")$"
)
KOREAN_NAME_RE = re.compile(r"^[가-힣]{2,4}$")

def extract_name_only_from_speaker(raw_text: str) -> Optional[str]:
    if not raw_text: return None
    cleaned = _strip_brackets_spaces(str(raw_text))
    if not cleaned: return None
    tokens = cleaned.split()
    personish = []
    for t in tokens:
        t_norm = t.strip()
        if (t_norm in ROLE_KWS) or ROLE_SUFFIX_RE.search(t_norm):
            continue
        personish.append(t_norm)
    for t in personish:
        if KOREAN_NAME_RE.match(t):
            return t
    alt = [t for t in personish if re.fullmatch(r"[가-힣]{2,5}", t)]
    if alt:
        return sorted(alt, key=len)[0]
    return personish[-1] if personish else (tokens[-1] if tokens else None)

# ===================== 임시 Person 관리자 ====================
class ProvisionalPersonManager:
    def __init__(self, start_from: int = 0):
        self.counter = start_from
        self.name_to_iri: Dict[str, str] = {}
        self.entries: List[Tuple[str, str]] = []  # (local_id, name_only)

    @staticmethod
    def _norm_key(name_text: str) -> str:
        return (name_text or "").replace(" ", "")

    def get_or_create(self, speaker_cell_text: str) -> Optional[str]:
        if not speaker_cell_text:
            return None
        name_only = extract_name_only_from_speaker(speaker_cell_text)
        if not name_only:
            name_only = _strip_brackets_spaces(speaker_cell_text)
        key = self._norm_key(name_only)
        if key in self.name_to_iri:
            return self.name_to_iri[key]
        self.counter += 1
        local_id = f"PER-TMP-{self.counter:05d}"
        iri_str = str(NADAT2[local_id])
        self.name_to_iri[key] = iri_str
        self.entries.append((local_id, name_only))
        return iri_str

    def write_ttl_txt(self, out_path: str):
        out_file = Path(out_path).expanduser().resolve()
        out_file.parent.mkdir(parents=True, exist_ok=True)
        lines = []
        lines.append('@prefix foaf:  <http://xmlns.com/foaf/0.1/> .')
        lines.append('@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .')
        lines.append('@prefix nam2:  <https://lseun135.github.io/NAontology_study/m2-person#> .')
        lines.append('@prefix nadat2: <https://lseun135.github.io/NAontology_study/resource/d2-person#> .')
        lines.append('')
        lines.append('## 임시개체')
        lines.append('')
        for local_id, name_only in self.entries:
            lines.append(f"nadat2:{local_id} a foaf:Person ;")
            lines.append(f'\trdfs:label "{name_only}"@ko ;')
            lines.append(f'\tfoaf:name "{name_only}"@ko ;')
            lines.append(f"\tnam2:isInAStateOf nam2:Provisional .")
            lines.append('')
        out_file.write_text("\n".join(lines), encoding="utf-8")
        print(f"[write] provisional persons txt: {out_file} (count={len(self.entries)})")

# ================= 날짜 인덱스 적재 & 해결/생성 =================
def _local_name(iri: str) -> str:
    if "#" in iri:
        return iri.rsplit("#", 1)[-1]
    iri2 = iri.rstrip("/")
    return iri2.rsplit("/", 1)[-1]

def _load_graph_from_source(src: str) -> Graph:
    g = Graph()
    raw_text = None
    try:
        if re.match(r"^https?://", src, re.I):
            with urllib.request.urlopen(src) as resp:
                raw_text = resp.read().decode("utf-8")
        else:
            p = Path(src)
            raw_text = p.read_text(encoding="utf-8")
    except Exception as e:
        if DEBUG_DATE_INDEX:
            print(f"[date-index][WARN] fetch/read failed: {src} :: {e}")
        raw_text = None

    if raw_text is not None:
        if "@prefix dcterms:" not in raw_text:
            raw_text = "@prefix dcterms: <http://purl.org/dc/terms/> .\n" + raw_text
        g.parse(data=raw_text, format="turtle")
    else:
        g.parse(src, format="turtle")
    return g

def preload_existing_date_index(sources: List[str], nadat1_base: Namespace):
    existing_date_iris: Set[str] = set()
    normalized_to_iris: Dict[str, Set[str]] = defaultdict(set)
    iri_to_normalized: Dict[str, str] = {}

    for src in sources or []:
        try:
            if DEBUG_DATE_INDEX:
                print(f"[date-index] open: {src}")
            g = _load_graph_from_source(src)
            if DEBUG_DATE_INDEX:
                print(f"[date-index] triples: {len(g)}")

            count_all_dates = 0
            accepted = 0
            for s, _, o in g.triples((None, RDF.type, None)):
                if str(o).endswith("#Date") and "RiC/ontology" in str(o):
                    count_all_dates += 1
                    s_str = str(s).replace("http://", "https://")
                    local = _local_name(s_str)
                    if not local.startswith("date-"):
                        continue
                    existing_date_iris.add(s_str)
                    accepted += 1
                    for ndv in g.objects(s, RICO.normalizedDateValue):
                        ndv_str = str(ndv)
                        if re.fullmatch(r"\d{4}-\d{2}-\d{2}", ndv_str):
                            normalized_to_iris[ndv_str].add(s_str)
                            iri_to_normalized[s_str] = ndv_str

            if DEBUG_DATE_INDEX:
                print(f"[date-index] rico:Date in file (any): {count_all_dates}, accepted(date-*): {accepted}")

        except Exception as e:
            print(f"[date-index][ERROR] parse failed for {src}: {e}")

    print(f"[date-index] preload done. kept={len(existing_date_iris)} (date-YYYY_MM_DD)")
    return existing_date_iris, normalized_to_iris, iri_to_normalized

def resolve_or_create_date_iri(
    g: Graph,
    y: int, m: int, d: int,
    expressed: Optional[str],
    existing_date_iris: Set[str],
    normalized_to_iris: Dict[str, Set[str]],
    iri_to_normalized: Dict[str, str],
    created_date_iris: Set[str]
) -> Tuple[str, bool]:
    local = f"date-{y:04d}_{m:02d}_{d:02d}"
    canonical_iri = str(NADAT1[local])
    normalized = date(y, m, d).isoformat()

    if canonical_iri in existing_date_iris or canonical_iri in created_date_iris:
        return canonical_iri, False

    if normalized in normalized_to_iris and normalized_to_iris[normalized]:
        use_iri = sorted(normalized_to_iris[normalized])[0]
        return use_iri, False

    d_node = URIRef(canonical_iri)
    g.add((d_node, RDF.type, RICO.Date))
    add_lit(g, d_node, RICO.identifier, local)
    add_lit(g, d_node, RICO.name, local)
    add_lit(g, d_node, RICO.normalizedDateValue, normalized, dt=XSD.date)
    if isinstance(expressed, str) and expressed.strip():
        add_lit(g, d_node, RICO.expressedDate, expressed.strip(), lang="ko")
    add_res(g, d_node, RICO.hasDateType, str(NAM1["singleDate"]))

    created_date_iris.add(canonical_iri)
    existing_date_iris.add(canonical_iri)
    normalized_to_iris.setdefault(normalized, set()).add(canonical_iri)
    iri_to_normalized[canonical_iri] = normalized
    return canonical_iri, True

# ===================== 메인 변환 =========================
def convert(csv_path, out_path, tmp_people_out_path,
            encoding="utf-8-sig", people_ttl_url=None):
    df = pd.read_csv(csv_path, encoding=encoding)

    g = Graph()
    g.bind("rdf", RDF); g.bind("rdfs", RDFS); g.bind("skos", SKOS)
    g.bind("dcterms", DCTERMS); g.bind("xsd", XSD); g.bind("foaf", FOAF); g.bind("owl", OWL)
    g.bind("rico", RICO); g.bind("org", ORG); g.bind("schema", SCHEMA)
    g.bind("nam1", NAM1); g.bind("nam2", NAM2); g.bind("nam3", NAM3)
    g.bind("nadat1", NADAT1); g.bind("nadat2", NADAT2); g.bind("nadat3", NADAT3)

    idx_exact, idx_nospace = build_person_index_from_ttl(people_ttl_url) if people_ttl_url else ({}, {})
    org_idx = build_org_index_from_ttl(people_ttl_url) if people_ttl_url else {}
    ou_label_to_iri, ou_label_to_ident = build_orgunit_maps(people_ttl_url) if people_ttl_url else ({}, {})
    print(f"[info] persons exact={len(idx_exact)}, nospace={len(idx_nospace)}; "
          f"orgs={len(org_idx)}; orgUnits={len(ou_label_to_ident)}")

    start_from = 0
    if people_ttl_url:
        try:
            gp = Graph()
            gp.parse(people_ttl_url, format="turtle")
            pat = re.compile(r"(?:/|#)PER-TMP-(\d{5})$")
            for s in gp.subjects():
                if isinstance(s, URIRef):
                    m = pat.search(str(s))
                    if m:
                        n = int(m.group(1))
                        if n > start_from:
                            start_from = n
        except Exception:
            start_from = 0
    print(f"[info] provisional start_from={start_from}")
    prov_mgr = ProvisionalPersonManager(start_from=start_from)

    existing_date_iris, normalized_to_iris, iri_to_normalized = preload_existing_date_index(
        PRELOAD_D1_TTLS, NADAT1
    )
    created_date_iris: Set[str] = set()

    seen_participants: Dict[str, set] = {}
    total_rows = 0
    linked_count = 0
    provisional_linked = 0
    stats = {"created": 0, "linked_existing_same_iri": 0, "linked_existing_by_normalized": 0}

    for _, row in df.iterrows():
        total_rows += 1

        mtg_no = int(row["회의번호"]) if not pd.isna(row["회의번호"]) else None
        if mtg_no is None: continue

        generation = int(row["대수"]) if not pd.isna(row["대수"]) else None
        rec_type   = str(row.get("회의록구분") or "").strip()
        meeting_tp = str(row.get("회의구분") or "").strip()
        committee  = str(row.get("위원회") or "").strip()
        session_raw = row.get("회수")
        round_raw   = row.get("차수")
        date_raw    = row.get("회의일자")

        session_num = digits_only(session_raw)
        session4    = pad(session_num, 4)
        round_num   = digits_only(round_raw)
        round3      = pad(round_num, 3)

        # 위원회 접미어 계산
        suffix = ""
        if isinstance(committee, str) and committee.strip():
            ident_raw = ou_label_to_ident.get(committee.strip())
            suffix_calc = derive_committee_suffix_from_identifier(ident_raw)
            if suffix_calc:
                suffix = suffix_calc

        # 1) Activity (회의번호)
        act = URIRef(NADAT1[f"ACT-M-{mtg_no}"])
        g.add((act, RDF.type, RICO.Activity))
        add_lit(g, act, RICO.identifier, f"ACT-M-{mtg_no}")
        label_act = f"[ACT-M-{mtg_no}]"
        if generation is not None: label_act += f" {generation}대"
        if rec_type:               label_act += f" {rec_type}"
        if committee:              label_act += f" {committee}"
        if session_raw and str(session_raw).strip(): label_act += f" {str(session_raw).strip()}"
        if round_raw and str(round_raw).strip():     label_act += f" {str(round_raw).strip()}"
        add_lit(g, act, SKOS.prefLabel, label_act, lang="ko")
        add_lit(g, act, RICO.name, f"제{generation}대 {rec_type} {committee} {session_raw} {round_raw}", lang="ko")
        add_lit(g, act, DCTERMS.identifier, f"{mtg_no}")
        add_res(g, act, RICO.hasActivityType, str(NAM1["StandingCommitteeMeeting"]))

        # performer 연결 규칙
        clabel = committee.strip() if isinstance(committee, str) else ""
        if clabel:
            ou_iri = ou_label_to_iri.get(clabel)
            if ou_iri:
                add_res(g, act, RICO.isOrWasPerformedBy, ou_iri)
                # performer 주체를 rico:Group으로 보장(중복X)
                u = URIRef(ou_iri)
                if (u, RDF.type, RICO.Group) not in g:
                    g.add((u, RDF.type, RICO.Group))
            else:
                ident = ou_label_to_ident.get(clabel)
                local = (ident if ident else re.sub(r"[^A-Za-z0-9._\-]", "", clabel.replace(" ", "_"))) or f"OU_{abs(hash(clabel))}"
                grp = URIRef(NADAT2[local])
                g.add((grp, RDF.type, RICO.Group))
                add_lit(g, grp, SKOS.prefLabel, clabel, lang="ko")
                if ident:
                    add_lit(g, grp, ORG.identifier, ident)
                add_res(g, act, RICO.isOrWasPerformedBy, str(grp))

        # 2) RecordSet S(대수)
        s_node = None
        if generation is not None:
            s_node = URIRef(NADAT1[f"S1000{generation}{suffix}"])
            g.add((s_node, RDF.type, RICO.RecordSet))
            add_lit(g, s_node, RICO.identifier, f"S1000{generation}{suffix}")
            s_label = f"[S1000{generation}{suffix}] {generation}대"
            if rec_type:   s_label += f" {rec_type}"
            if committee:  s_label += f" {committee}"
            add_lit(g, s_node, SKOS.prefLabel, s_label, lang="ko")
            add_lit(g, s_node, RICO.classification, "A")
            add_lit(g, s_node, RICO.name, f"제{generation}대 {rec_type} {committee}", lang="ko")

        # 3) RecordSet F(회수)
        f_node = None
        if generation is not None and session4 is not None:
            session_str = str(session_raw).strip() if session_raw else ""   # ★ 미정의 방지
            f_node = URIRef(NADAT1[f"F1000{generation}{session4}{suffix}"])
            g.add((f_node, RDF.type, RICO.RecordSet))
            add_lit(g, f_node, RICO.identifier, f"F1000{generation}{session4}{suffix}")
            f_label = f"[F{session4}{suffix}]"
            if generation is not None: f_label += f" {generation}대"
            if committee:             f_label += f" {committee}"
            if session_raw and str(session_raw).strip(): f_label += f" {str(session_raw).strip()}"
            add_lit(g, f_node, SKOS.prefLabel, f_label, lang="ko")
            add_lit(g, f_node, RICO.name, f"제{generation}대 {rec_type} {committee} {session_str}", lang="ko")
            add_lit(g, f_node, RICO.classification, "A")
            add_lit(g, f_node, RICO.conditionsOfAccess, "공개", lang="ko")
            add_lit(g, f_node, RICO.conditionsOfAccess, "Open", lang="en")
            add_lit(g, f_node, RICO.conditionsOfUse,
                    "공공누리 제3유형 (출처표시 + 변경금지) 조건에 따라 자유롭게 이용이 가능합니다.", lang="ko")
            add_res(g, f_node, RICO.hasContentOfType, str(NAM1["text"]))
            add_res(g, f_node, RICO.hasOrHadLegalStatus, str(NAM1["public"]))
            if s_node is not None:
                g.add((s_node, RICO.includesOrIncluded, f_node))

        # 4) Record R(차수)
        r_node = None
        if generation is not None and session4 is not None and round3 is not None:
            r_node = URIRef(NADAT1[f"R1000{generation}{session4}{round3}{mtg_no}"])
            g.add((r_node, RDF.type, RICO.Record))
            add_lit(g, r_node, RICO.identifier, f"R1000{generation}{session4}{round3}{mtg_no}")
            r_label = f"[R1000{generation}{session4}{round3}{mtg_no}] {generation}대"
            if committee and str(committee).strip():     r_label += f" {str(committee).strip()}"
            if session_raw and str(session_raw).strip(): r_label += f" {str(session_raw).strip()}"
            if round_raw and str(round_raw).strip():     r_label += f" {str(round_raw).strip()} 회의록"
            add_lit(g, r_node, SKOS.prefLabel, r_label, lang="ko")

            title = ""
            if session_num is not None: title += f"제{session_num}회국회 "
            if committee:               title += f"{committee}회의록 "
            if round_num is not None:   title += f"제 {round_num} 호"
            add_lit(g, r_node, RICO.title, title.strip(), lang="ko")

            add_lit(g, r_node, RICO.classification, "A")

            # Record → Activity
            g.add((r_node, RICO.documents, act))

            if f_node is not None:
                g.add((f_node, RICO.includesOrIncluded, r_node))

            add_lit(g, r_node, RICO.conditionsOfAccess, "공개", lang="ko")
            add_lit(g, r_node, RICO.conditionsOfAccess, "Open", lang="en")
            add_lit(g, r_node, RICO.conditionsOfUse,
                    "공공누리 제3유형 (출처표시 + 변경금지) 조건에 따라 자유롭게 이용이 가능합니다.", lang="ko")
            add_res(g, r_node, RICO.hasContentOfType, str(NAM1["text"]))
            add_res(g, r_node, RICO.hasOrHadLegalStatus, str(NAM1["public"]))
            add_res(g, r_node, RICO.hasOrHadLanguage, str(NAM1["lang-kor"]))

            # 4-1) DATE-DEDUP
            ymd = parse_date_simple(date_raw)
            if ymd:
                y, m, d = ymd
                iri_to_use, was_created = resolve_or_create_date_iri(
                    g, y, m, d,
                    expressed=(str(date_raw) if isinstance(date_raw, str) else None),
                    existing_date_iris=existing_date_iris,
                    normalized_to_iris=normalized_to_iris,
                    iri_to_normalized=iri_to_normalized,
                    created_date_iris=created_date_iris
                )
                add_res(g, r_node, RICO.hasCreationDate, iri_to_use)

                # (주의) 업로드 TTL과 완전 동일성을 원하면 아래 줄은 제거
                g.add((URIRef(iri_to_use), RICO.isDateOfOccurrenceOf, act))

                if was_created:
                    stats["created"] += 1
                else:
                    local = f"date-{y:04d}_{m:02d}_{d:02d}"
                    canonical_iri = str(NADAT1[local])
                    if iri_to_use == canonical_iri:
                        stats["linked_existing_same_iri"] += 1
                    else:
                        stats["linked_existing_by_normalized"] += 1

        # 5) Participants
        name, iri, role, original_speaker = parse_speaker_name(row.get("발언자"), idx_exact, idx_nospace)
        if iri:
            key = f"ACT-M-{mtg_no}"
            seen_participants.setdefault(key, set())
            if iri not in seen_participants[key]:
                seen_participants[key].add(iri)
                add_res(g, act, RICO.hasOrHadParticipant, iri)
                linked_count += 1
        else:
            speaker_text_for_label = original_speaker if original_speaker else row.get("발언자")
            tmp_iri = prov_mgr.get_or_create(speaker_text_for_label)
            if tmp_iri:
                key = f"ACT-M-{mtg_no}"
                seen_participants.setdefault(key, set())
                if tmp_iri not in seen_participants[key]:
                    seen_participants[key].add(tmp_iri)
                    add_res(g, act, RICO.hasOrHadParticipant, tmp_iri)
                    provisional_linked += 1

    # 저장(d1)
    out_file = Path(out_path).expanduser().resolve()
    out_file.parent.mkdir(parents=True, exist_ok=True)
    g.serialize(destination=out_file.as_posix(), format="turtle")
    print(f"[done] rows={total_rows}, participants_linked(existing)={linked_count}, provisional_linked={provisional_linked}")
    print(f"[date] created={stats['created']}, linked_existing_same_iri={stats['linked_existing_same_iri']}, linked_existing_by_normalized={stats['linked_existing_by_normalized']}")
    print(f"[write] {out_file}")

    # 저장(임시 Person TTL txt, d2 보완용)
    prov_mgr.write_ttl_txt(tmp_people_out_path)

# ========================= 실행 ==========================
if __name__ == "__main__":
    convert(CSV_PATH, OUT_TTL, OUT_TMP_PEOPLE, encoding=CSV_ENCODING, people_ttl_url=PEOPLE_TTL)

